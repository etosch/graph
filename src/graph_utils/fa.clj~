;; note: input is in lexicographic order, not order of being processed
;; i.e. it's reversed
(ns graph-utils.fa
  ^{:doc "Finite Automaton implementation"
    :author "Emma Tosch"}
  (:require [graph][aux])
  (:import [java.lang.Math]))

(def *verbose* (atom false))

(defn add-edge
  [loc from to test transition-update read]
  (let [g (graph/add-edge loc from to test transition-update)]
    (if (= (graph/edges g) (graph/edges loc))
      g
      (with-meta g
	(assoc (meta g)
	  :edges (let [edge (aux/find-first #(and (= from (:from %))
					      (= to (:to %)))
					(graph/edges g))]
		   (cons (assoc edge :read read)
			 (remove #(= edge %) (graph/edges g)))))))))
	  
(defn edge-transition-rule
  "General form of a fa transition rule."
  [from to read]
  (fn [loc input]
    (assert (meta loc))
    (graph/make-graph loc to (conj (graph/path loc) from)
		(cond (= read :epsilon)(:input (loc 1))
		      input [(rest (graph/input-remaining loc))
			     (aux/rcons read (graph/input-processed loc))]
		      :else [nil (aux/rcons read (graph/input-processed loc))])
		nil)))

(defn edge-test
  [read]
  (fn [loc input] (assert (meta loc))
    (or (= read :epsilon) (not input) (= read input))))

(defn fa-graph
  "Returns a graph representing a finite automaton.

transition-map is a nested map where the keys are references to states and the values are maps from an emission to another state. Multiple destination states may be specified by referring to a sequence of states. Epsilon transitions are encoded with :epsilon. Other transitions are encoded with :other

start-node-map is a map specifying legal moves from start state 'start.

accept-node-set is a set of state references

input is a sequence or string to be processed. If the input is anything other than a sequence or string, graph is passed the empty list."
  ([transition-map start-node-map accept-node-set]
     (fa-graph transition-map start-node-map accept-node-set nil))
  ([transition-map start-node-map accept-node-set input]
  (let [transition-map (merge transition-map start-node-map)]
    ;; I put earmuffs on the local functions to make them visually stand out.
    (letfn [(*accept-rule*
	     ([loc]
		(contains? accept-node-set (graph/node loc)))
	     ([loc input]
		(and ((complement aux/not-nil-or-empty?) input)
		     (contains? accept-node-set (graph/node loc)))))
	    (*reject-rule*
 	     ([loc]
 		(seq (graph/next-processor loc input)))
	     ([loc input]
		(and (not (*accept-rule* loc input))
		     ((complement aux/not-nil-or-empty?) (graph/next-processor loc input)))))]
      (graph/graph (set (flatten (for [[from trans] transition-map] [from (vals trans)])))
	     (for [[from trans] transition-map
		   [read states] trans
		   to (if (coll? states) states (list states))]
	       {:from from :to to :test (edge-test read)
		:transition-update (edge-transition-rule from to read)
		:read read})
	     (cond (coll? input) input (string? input) (map str input) :else '())
	     *accept-rule*
	     *reject-rule*
	     input)))))

(defn enumerate-by-stream [loc]
  ;; left-recursion issue with simpler implementations
  ;; memoization did NOT make this run faster
  "Returns a lazy sequence of all strings, ordered by length"
  (letfn [(step [steps loc]
		(assert (meta loc))
		(if (zero? steps)
		  (if ((graph/accept-fn loc) loc) (list loc) '())
		  (mapcat #(step (dec steps) %) (graph/next-generator loc))))
	  (step-wise [s] (concat (step s loc) (lazy-seq (step-wise (inc s)))))]
    (step-wise 1)))

(defn enumerate-by-steps [loc n]
  "Returns a lazy sequence of all strings generated by running the machine for n steps"
  (loop [times n retval '() nexts (graph/next-generator loc)] ;;transients on retval made no difference in performance
    (if (zero? times)
      retval
      (recur (dec times)
	     (concat retval (filter #((graph/accept-fn loc) %) nexts))
	     (graph/next-generator nexts)))))

(defn enumerate-strings [loc n]
  "Enumerates the first n strings"
  (loop [ret-val (transient []) check-these (graph/next-generator loc) group-1 (transient (vec check-these)) group-2 (transient [])]
    (if (and (zero? (count check-these)) (zero? (count group-1)) (zero? (count group-2)))
      (persistent! (reduce conj! ret-val (repeat (- n (count ret-val)) nil)))
      (let [accepts (filter (graph/accept-fn loc) check-these)]
	(aux/if-let* [ret-val-size (count ret-val)
		      accepts-size (aux/return-if-all (count accepts) #(< (+ ret-val-size %) n))
		      group-1-size (count group-1)
		      group (or (and (zero? group-1-size) group-2) group-1)
		      nexts (graph/next-generator (nth group (dec (count group))))]
		     (recur (if (zero? (count accepts)) ret-val (reduce conj! ret-val (map graph/input-processed accepts)))
			    nexts
			    (pop! group)
			    (if (zero? group-1-size) (transient (vec nexts)) (reduce conj! group-2 nexts)))
		     (persistent! (reduce conj! ret-val (map graph/input-processed (take (- n (count ret-val)) accepts)))))))))


;; (Defn evaluate [loc]
;;   "Evaluates a single graph, given that it contains its input."
;;   (assert (meta loc))
;;   (letfn [(branches [loc]
;; 		    (assert (meta loc))
;; 		    (cond ((graph/accept-fn loc) loc (first (graph/input-remaining loc))) :accept
;; 			  ((graph/reject-fn loc) loc (first (graph/input-remaining loc))) :reject
;; 			  :else (map branches (graph/next-processor loc))))]
;;     (or (find-first #(= :accept %) (flatten (branches loc))) :reject)))

(defn visits [loc]
  (:visits (meta (get (graph/nodes loc) (graph/node loc))) 0))

(defn tag-state [loc]
  "Tags a state as having been visited. Used for cycle detection."
  (with-meta loc (assoc (meta loc) :nodes
			(conj (disj (graph/nodes loc) (graph/node loc))
			      (with-meta (graph/node loc) {:visits (inc (visits loc))})))))

(defn evaluate [loc]
  ;; if |this-gen| > |my-children|^|this-gen|, dfs else bfs
  "Should be evaluated on a graph that holds its input in the input field. If the graph does not currently hold its input, it can be
added using the with-input function.
Returns an atom whose value is either the keyword :accept or :reject. Metadata is also returned indicating the frequencies of the search techniques.
Verbose turns on a printer that prints to standard out one + for every 100 steps the search in the evaluation function takes."
  (let [max-visits (count (graph/input-remaining loc))
	break (atom nil :meta {:dfs 0 :bfs 0 :det 0})]
    (loop [this-gen (transient (vec (graph/next-processor loc)))]
      (let [me (get this-gen (dec (count this-gen)))
	    siblings (when-not (zero? (count this-gen)) (pop! this-gen))]
	(cond (or (not me) (> (visits me) max-visits)) (and (reset! break :reject) break)
 	      ((graph/reject-fn me) me (first (graph/input-remaining me))) (do (alter-meta! break #(assoc % :det (inc (:det %))))
 								    (recur siblings))
 	      ((graph/accept-fn me) me (first (graph/input-remaining me))) (and (reset! break :accept) break)
 	      :else (let [children (graph/next-processor (tag-state me))] ;;tag current node as I leave this state
 		      (when (and @*verbose* (= 0 (mod (apply + (vals (meta break))) 100)))
 			(print "-"))
		      (do (alter-meta! break #(assoc % :dfs (inc (:dfs %))))
 			    (recur (reduce conj! siblings children)))))))))

;;  (defn evaluate [loc]
;;   ;; if |this-gen| > |my-children|^|this-gen|, dfs else bfs
;;   "Should be evaluated on a graph that holds its input in the input field. If the graph does not currently hold its input, it can be
;; added using the with-input function.
;; Returns an atom whose value is either the keyword :accept or :reject. Metadata is also returned indicating the frequencies of the search techniques.
;; Verbose turns on a printer that prints to standard out one + for every 100 steps the search in the evaluation function takes."
;;   (let [max-visits (count (input-remaining loc))
;; 	break (atom nil :meta {:dfs 0 :bfs 0 :det 0})]
;;     (loop [this-gen (next-processor loc)]
;;       (let [me (first this-gen)
;; 	    siblings (rest this-gen)]
;; 	;;(println me "visits:" (visits me) "input remaining:" (input-remaining me))
;; 	(cond (or (not me) (> (visits me) max-visits)) (and (reset! break :reject) break)
;;  	      ((reject-fn me) me (first (input-remaining me))) (do (alter-meta! break #(assoc % :det (inc (:det %))))
;;  								    (recur siblings))
;;  	      ((accept-fn me) me (first (input-remaining me))) (and (reset! break :accept) break)
;;  	      :else (let [children (next-processor (tag-state me))] ;;tag current node as I leave this state
;;  		      (when (and @*verbose* (= 0 (mod (apply + (vals (meta break))) 100)))
;;  			(print "-"))
;;  		      (if (> (count siblings) (Math/pow (count children) (count siblings)))
;;  			(do (alter-meta! break #(assoc % :dfs (inc (:dfs %))))
;;  			    (recur (concat children siblings)))
;; 			(do (alter-meta! break #(assoc % :bfs (inc (:bfs %))))
;;  			    (recur (concat siblings children))))))))))


(def a*ab (fa-graph {'a* {"a" ['a* 'a*a]}
		      'a*a {"b" 'a*ab}}
		      {'start {"a" ['a* 'a*a] "b" 'dead :epsilon 'dead-2}}
		      #{'a*ab}
		      "aab"))

(def evo (fa-graph {'NODE42905 {:epsilon 'accept}
		    'NODE42904 {:epsilon 'accept}
		    'accept {"a" 'NODE42904 "b" ['NODE42905 'accept]}}
		   {'start {:epsilon 'accept}}
		   #{'accept}))
		   

;;(map #(apply str %) (map input-processed (take 5 (enumerate a*ab))))
