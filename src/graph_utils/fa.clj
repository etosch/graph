;; note: input is in lexicographic order, not order of being processed
;; i.e. it's reversed
(ns graph-utils.fa
  ^{:doc "Finite Automaton implementation"
    :author "Emma Tosch"}
  (:require [aux])
  (:use [graph])
  (:import [java.lang.Math]))

(def *verbose* (atom false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Auxilary functions for regexps

(defn merge-map [transition-map new-entry]
  "A special form of merge that performs a piece-wise merging of data. Used in parsing regexps."
  (aux/if-let* [key (first (keys new-entry))
		read (first (keys (get new-entry key)))
		dest (get (get new-entry key) read)
		old-entry (get transition-map key)]
	       (if (some #(= read %) (keys (get transition-map key)))
		 (merge transition-map
			{key {read (vec (cons dest (aux/ensure-list (get (get transition-map key) read))))}})
		 (merge transition-map
			{key (merge (get transition-map key) (get new-entry key))}))
	       (merge transition-map new-entry)))

(defn add-edge
  "Replaces graph's add-edge so that each edge is annotated with the read symbol"
  [loc from to test transition-update read]
  (let [g (add-directed-edge loc from to test transition-update)]
    (if (= (edges g) (edges loc))
      g
      (with-meta g
	(assoc (meta g)
	  :edges (let [edge (aux/find-first #(and (= from (:from %))
					      (= to (:to %)))
					(edges g))]
		   (cons (assoc edge :read read)
			 (remove #(= edge %) (edges g)))))))))
	  
(defn edge-transition-rule
  "General form of a fa transition rule."
  [from to read]
  (fn [loc input]
    (assert (meta loc))
    (make-graph loc to (conj (path loc) from)
		(cond (= read :epsilon)(:input (loc 1))
		      input [(rest (input-remaining loc))
			     (aux/rcons read (input-processed loc))]
		      :else [nil (aux/rcons read (input-processed loc))])
		nil)))

(defn edge-test
  [read]
  (fn [loc input] (assert (meta loc))
    (or (= read :epsilon) (not input) (= read input))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; fa "constructor"

(defn fa-graph
  "Returns a graph representing a finite automaton.

transition-map is a nested map where the keys are references to states and the values are maps from an emission to another state. Multiple destination states may be specified by referring to a sequence of states. Epsilon transitions are encoded with :epsilon. Other transitions are encoded with :other

start-node-map is a map specifying legal moves from start state 'start.

accept-node-set is a set of state references

input is a sequence or string to be processed. If the input is anything other than a sequence or string, graph is passed the empty list."
  ([transition-map start-node-map accept-node-set]
     (fa-graph transition-map start-node-map accept-node-set nil))
  ([transition-map start-node-map accept-node-set input]
  (let [transition-map (merge transition-map start-node-map)]
    ;; I put earmuffs on the local functions to make them visually stand out.
    (letfn [(*accept-rule*
	     ([loc]
		(contains? accept-node-set (node loc)))
	     ([loc input]
		(when-not (aux/not-nil-or-empty? input)
		  (contains? accept-node-set (node loc)))))
	    (*reject-rule*
 	     ([loc]
 		(seq (next-processor loc input)))
	     ([loc input]
		(when-not (or (*accept-rule* loc input)
			       (aux/not-nil-or-empty? input))
		  (seq (next-processor loc input)))))]
      (graph (set (flatten (for [[from trans] transition-map] [from (vals trans)])))
	     (for [[from trans] transition-map
		   [read states] trans
		   to (if (coll? states) states (list states))]
	       {:from from :to to :test (edge-test read)
		:transition-update (edge-transition-rule from to read)
		:read read})
	     (cond (coll? input) input (string? input) (map str input) :else '())
	     *accept-rule*
	     *reject-rule*
	     input)))))

(defn visits [loc]
  (:visits (meta (get (nodes loc) (node loc))) 0))

(defn accepts [loc]
  (:accepts (meta (get (nodes loc) (node loc))) #{}))

(defn tag-state [loc tag fun]
  "Tags a state as having been visited. Used for cycle detection."
  (with-meta loc (assoc (meta loc) :nodes
			(conj (disj (nodes loc) (node loc))
			      (with-meta (node loc) {tag (fun loc)})))))

(defn enumerate-by-stream [loc]
  ;; left-recursion issue with simpler implementations
  ;; memoization did NOT make this run faster
  "Returns a lazy sequence of all strings, ordered by length"
  (letfn [(step [steps loc]
		(assert (meta loc))
		(if (zero? steps)
		  (if ((accept-fn loc) loc) (list loc) '())
		  (mapcat #(step (dec steps) %) (next-generator loc))))
	  (step-wise [s] (concat (step s loc) (lazy-seq (step-wise (inc s)))))]
    (step-wise 1)))

(defn enumerate-by-steps [loc n]
  "Returns a lazy sequence of all strings generated by running the machine for n steps"
  (loop [times n retval '() nexts (next-generator loc)] ;;transients on retval made no difference in performance
    (if (zero? times)
      retval
      (recur (dec times)
	     (concat retval (filter #((accept-fn loc) %) nexts))
	     (next-generator nexts)))))


(defn enumerate-strings [loc n]
  "Enumerates the first n strings"
    ;; Temporary solution to deal with nonproductive nonterminating solutions: run for 2^|edges| steps
  ;; Will add more optimizing heuristics later
  ;; Putting a transient on the ret-val does little, since it's not growing very fast
  ;; putting a transient on nexts reduced 100 repeated draws of 100 strings from >5000ms to
  ;; ~2000ms.
  (loop [nexts (transient [loc]) ret-val #{} steps 0]
    (if (or (zero? (count nexts))
	    (> steps (Math/pow 2 (count (edges loc))))
	    (> steps (Math/pow 2 32)))
      ret-val
      (let [this-level (next-generator (nth nexts 0))
	    accepts (map #(or (seq (input-processed %)) '(:epsilon))
			 (filter (accept-fn loc) this-level))]
	(cond ;; if we've collected enough strings
	 (> (+ (count ret-val) (count accepts)) n)
	 (reduce conj ret-val (take (- n (count accepts)) accepts))
	 ;; if new locs were generated at this level
	 (seq this-level)
	 (recur (do
		  (doseq [i (range (dec (count nexts)))]
		    (assoc! nexts i (get nexts (inc i))))
		  (pop! nexts)
		  (conj! nexts this-level))
		(reduce conj ret-val accepts)
		(inc steps))
	 ;;if no new locs were generated
	 :else (recur (do
			(doseq [i (range (dec (count nexts)))]
			  (assoc! nexts i (get nexts (inc i))))
			(pop! nexts))
		      (reduce conj ret-val accepts)
		      (inc steps)))))))

(defn evaluate [loc]
  ;; if |this-gen| > |my-children|^|this-gen|, dfs else bfs
  "Should be evaluated on a graph that holds its input in the input field. If the graph does not currently hold its input, it can be
added using the with-input function.
Returns an atom whose value is either the keyword :accept or :reject. Metadata is also returned indicating the frequencies of the search techniques.
Verbose turns on a printer that prints to standard out one + for every 100 steps the search in the evaluation function takes."
  (let [max-visits (count (input-remaining loc))
	break (atom nil :meta {:dfs 0 :bfs 0 :det 0})]
    (loop [this-gen (transient (vec (next-processor loc)))]
      ;; (println "me:" (get this-gen (dec (count this-gen)))
      ;; 	       "\nvisits:" (get this-gen (dec (count this-gen)))
      ;; 	       "siblings:" (dec (count this-gen)))
      (aux/if-let* [me (get this-gen (dec (count this-gen)))
		    v (< (visits me) max-visits)
		    siblings (pop! this-gen)]
		   (cond ((reject-fn me) me (first (input-remaining me)))
			 (do (alter-meta! break #(assoc % :det (inc (:det %))))
			     (recur siblings))
			 ((accept-fn me) me (first (input-remaining me)))
			 (do (reset! break :accept)
			     break)
			 :else (let [children (next-processor (tag-state me :visits #(inc (visits %))))] ;;tag current node as I leave this state
				 (when (and @*verbose* (= 0 (mod (apply + (vals (meta break))) 100)))
				   (print "-"))
				 (do (alter-meta! break #(assoc % :dfs (inc (:dfs %))))
				     (recur (reduce conj! siblings children)))))
		   (do
		     (reset! break :reject)
		     break)))))


;;  (defn evaluate [loc]
;;   ;; if |this-gen| > |my-children|^|this-gen|, dfs else bfs
;;   "Should be evaluated on a graph that holds its input in the input field. If the graph does not currently hold its input, it can be
;; added using the with-input function.
;; Returns an atom whose value is either the keyword :accept or :reject. Metadata is also returned indicating the frequencies of the search techniques.
;; Verbose turns on a printer that prints to standard out one + for every 100 steps the search in the evaluation function takes."
;;   (let [max-visits (count (input-remaining loc))
;; 	break (atom nil :meta {:dfs 0 :bfs 0 :det 0})]
;;     (loop [this-gen (next-processor loc)]
;;       (let [me (first this-gen)
;; 	    siblings (rest this-gen)]
;; 	;;(println me "visits:" (visits me) "input remaining:" (input-remaining me))
;; 	(cond (or (not me) (> (visits me) max-visits)) (and (reset! break :reject) break)
;;  	      ((reject-fn me) me (first (input-remaining me))) (do (alter-meta! break #(assoc % :det (inc (:det %))))
;;  								    (recur siblings))
;;  	      ((accept-fn me) me (first (input-remaining me))) (and (reset! break :accept) break)
;;  	      :else (let [children (next-processor (tag-state me))] ;;tag current node as I leave this state
;;  		      (when (and @*verbose* (= 0 (mod (apply + (vals (meta break))) 100)))
;;  			(print "-"))
;;  		      (if (> (count siblings) (Math/pow (count children) (count siblings)))
;;  			(do (alter-meta! break #(assoc % :dfs (inc (:dfs %))))
;;  			    (recur (concat children siblings)))
;; 			(do (alter-meta! break #(assoc % :bfs (inc (:bfs %))))
;;  			    (recur (concat siblings children))))))))))



(defn parse
  [regexp-string]
  (loop [remaining-list (map str regexp-string) stack []]
;;    (println remaining-list "\t" stack)
    (cond (empty? remaining-list)
	  (if (= 1 (count stack))
	    (peek stack)
	    (list (peek (pop stack)) (peek (aux/nth-app pop 2 stack)) (peek stack)))
	  ;; if the stack is empty or we're in a grouping, push the first item
	  (or (empty? stack) (= (peek stack) "("))
	  (recur (rest remaining-list) (conj stack (first remaining-list)))
	  ;; r = (s)
	  (= (first remaining-list) "(")
	  (if (not= (peek stack) "+")
	    (recur (rest remaining-list) (conj stack "." "("))
	    (recur (rest remaining-list) (conj stack "(")))
	  (= (first remaining-list) ")")
	  (if (and (not= (second remaining-list) "*")
		   (or (= (peek (pop stack)) ".")
		       (= (peek (pop stack)) "+")))
	    (recur (rest remaining-list) (conj (aux/nth-app pop 4 stack) (list (peek (aux/nth-app pop 2 stack))
									       (peek (aux/nth-app pop 3 stack))
									       (peek stack))))
	    (recur (rest remaining-list) (conj (aux/nth-app pop 2 stack) (peek stack))))
	  ;; r = s*
	  (= (first remaining-list) "*")
	  (if (or (= (peek (pop stack)) ".")
		  (= (peek (pop stack)) "+"))
	    (recur (rest remaining-list) (conj (aux/nth-app pop 3 stack)
					       (list (peek (pop stack))
						     (peek (aux/nth-app pop 2 stack))
						     (list "*" (peek stack)))))
	    (recur (rest remaining-list) (conj (pop stack) (list "*" (peek stack)))))
	  ;; r = s|t
	  (or (= (first remaining-list) "|") (= (first remaining-list) "+"))
	  (if (= (second remaining-list) "(")
	    (recur (rest remaining-list) (conj stack "+"))
	    (recur (aux/nth-app rest 2 remaining-list)
		   (conj (pop stack)
			 (list "+" (peek stack) (second remaining-list)))))
	  ;; r = st
	  ;; if the next read is followed by a high precedence op, defer
	  (and (seq stack) (= (peek stack) ".") (= (second remaining-list) "*"))
	  (recur (rest remaining-list) (conj stack (first remaining-list)))
	  ;; otherwise,concat
	  (and (seq stack) (= (peek stack) "."))
	  (recur (rest remaining-list) (conj (aux/nth-app pop 2 stack)
					     (list (peek stack)
						   (peek (pop stack))
						   (first remaining-list))))
	  ;; else push value and a concat op
	  :else (recur remaining-list (conj stack ".")))))

(defn regexp-to-nfa [regexp-string]
  "McNaughton-Yamada-Thompson algorithm"
  (letfn [(*terminal* [r] (let [i (gensym) f (gensym)]
			    {:transitions {i {r f}}
			     :accept f :start i}))
	  (*kleene* [r]
		    (let [i (gensym) f (gensym)]
		      {:transitions (-> (:transitions r)
					(merge-map {i {:epsilon (:start r)}})
					(merge-map {i {:epsilon f}})
					(merge-map {(:accept r) {:epsilon f}})
					(merge-map {(:accept r) {:epsilon (:start r)}}))
		       :start i :accept f}))
	  (*concat* [s t]
		    {:transitions (-> (:transitions s)
				      (merge-map (:transitions t))
				      (merge-map {(:accept s) {:epsilon (:start t)}}))
		       :start (:start s) :accept (:accept t)})
	  (*union* [s t]
		   (let [i (gensym) f (gensym)]
		     {:transitions (-> (:transitions s)
				       (merge-map (:transitions t))
				       (merge-map {i {:epsilon (:start s)}})
				       (merge-map {i {:epsilon (:start t)}})
				       (merge-map {(:accept s) {:epsilon f}})
				       (merge-map {(:accept t) {:epsilon f}}))
		      :start i :accept f}))
	  (*traverse* [parse-tree]
		      (if (not (coll? parse-tree))
			(*terminal* parse-tree)
			(case (first parse-tree)
			    "*" (*kleene* (*traverse* (second parse-tree)))
			    "." (*concat* (*traverse* (second parse-tree))
					  (*traverse* (aux/third parse-tree)))
			    "+" (*union* (*traverse* (second parse-tree))
					 (*traverse* (aux/third parse-tree))))))]
    (let [m (*traverse* (parse regexp-string))]
      (fa-graph (:transitions m) {'start {:epsilon (:start m)}} #{(:accept m)}))))
    
					  

(def a*ab (fa-graph {'a* {"a" ['a* 'a*a]}
		      'a*a {"b" 'a*ab}}
		      {'start {"a" ['a* 'a*a] "b" 'dead :epsilon 'dead-2}}
		      #{'a*ab}
		      "aab"))

(def evo (fa-graph {'NODE42905 {:epsilon 'accept}
		    'NODE42904 {:epsilon 'accept}
		    'accept {"a" 'NODE42904 "b" ['NODE42905 'accept]}}
		   {'start {:epsilon 'accept}}
		   #{'accept}))


(def no-strings (fa-graph {'accept {:epsilon 'accept}}
			  {'start {:epsilon 'accept}}
			   #{'accept}))
			   

;;(map #(apply str %) (map input-processed (take 5 (enumerate a*ab))))
