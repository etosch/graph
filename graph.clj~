(ns ^{:doc "An immutable representation of a graph, closely modelled on
on Rich Hickey's zipper implementation (clojure.zip). Extends the graph representation of
Jeffrey Straszheim (clojure.contrib.graph)."
      :author "Emma Tosch"}
  graph-utils
  (:require [clojure.contrib.math :as math]
	    [clojure.contrib.graph :as graph])
  (:refer-clojure :exclude (replace remove next)))

;; write macro for converting input to meta map
;; add changed? boolean
;; add a function to connect two given nodes
;; keep these implemented as closures - goal is to wrap push functions in transition functions

(defn graph
  ([states transition-rules transition-function start-rule make-node-fn
    dead-state? terminal-action associated-data-structure]
     ^{:neighbors transition-rules ;; rename transition-rules
       :transition-function (fn [loc input]
			      "This is a hack to deal with the case where a state has been removed.
If we try to go to a state that no longer exists, perform terminal action."
   			      (let [to-state ((transition-function loc) input)]
				(if (contains? states to-state) to-state (terminal-action to-state))))
       :nodes states
       :ads associated-data-structure
       :make-node make-node-fn
       :dead-state? dead-state?
       :terminal-action terminal-action}
     [(start-rule states) nil])
  ([states transition-rules state-accessor start-rule make-node-fn
    dead-state? terminal-action]
     (graph states transition-rules state-accessor start-rule make-node-fn
	    dead-state? terminal-action nil)))

(defn node
  [loc]
  (loc 0))

(defn get-neighbors
  "Based on get-neighbors in the graph namespace, this version
gets neighbors based upon the current location of the graph"
  [loc]
  (graph/get-neighbors (meta loc) (node loc)))

(defn- ensure-set [s]
  (cond (set? s) s
	(seq? s) (set s)
	:else (set (list s))))

(defn dead-state?
  "Like zip's branch?, only this returns whether or not the node
can connect to any node other than itself, regardless of input."
  [loc]
  ((:dead-state? (meta loc)) loc))

(defn make-node
  "Modelled directly on the zip make-node implementation"
  [loc node transitions]
  ((:make-node (meta loc)) node transitions))

;; (defn remove
;;   "Moves back to the previously visited node and removes the reference to
;; the state from the list of states "
;;   [loc]
;;   (with-meta
;;     (first (prev loc))
;;     ((second (prev loc))
  

(defn path
  "Modelled directly on the zip path implementation"
  [loc]
  (:pnodes (loc 1)))

(defn next [loc i]
  (if (or (nil? i) (dead-state? loc))
    ((:terminal-action (meta loc)) loc)
    (with-meta 
      [((:transition-function (meta loc)) loc i)
       (assoc (loc 1) :pnodes (conj (path loc) (node loc)))]
      (meta loc))))

(defn start?
  [loc]
  (empty? (path loc)))

(in-ns 'graph-utils)

(defn prev [loc]
  (if (start? loc)
    loc
    (with-meta
      [(first (path loc))
       (when (not (empty? (rest (path loc))))
	 (assoc (loc 1) :pnodes (rest (path loc))))]
      (meta loc))))
      
(defn max-num-edges
  "Returns the number of edges in a physical model (nothing is counted twice)"
  [num-nodes directed?]
  (if directed?
    (+ num-nodes (reduce + (range num-nodes)))
    (+ num-nodes (* (dec num-nodes) num-nodes))))

(defn-
  ^{:test (fn [] (assert (fully-connected? {:a #{:a}} true)))}
  fully-connected?
  [transition-map directed?]
    (= (max-num-edges (count (keys transition-map)) directed?)
       (count (flatten (vals transition-map)))))

(defn-
  ^{:test (fn [] (assert (and (not (choose-random-unconnected-nodes {:a #{:a}} true))
			      (let [[from to] (choose-random-unconnected-nodes {:a #{:a :b} :b #{:a}} false)]
				(and (= from :b) (= to :b)))
			      (let [[from to] (choose-random-unconnected-nodes {:a #{:a :b} :b #{:b}} true)]
				(and (= from :b) (= to :a)))
			      )))}
  choose-random-unconnected-nodes
  [transition-map directed?]
  (loop [nodes (keys transition-map)
	 from (rand-nth nodes)
	 to (rand-nth nodes)]
    (if (= (count (transition-map from)) (count nodes))
      (and (not (fully-connected? transition-map directed?))
	   (recur nodes (rand-nth nodes) to))
      (if (contains? (transition-map from) to)
	(do (if (not directed?)
	      (assert (contains? (transition-map to) from)))
	    (recur nodes (rand-nth nodes) (rand-nth nodes))) 
	[from to]))))
	
(defn generate-random-graph
  ([num-nodes density directed?]
     (loop [connections (int (* (max-num-edges num-nodes directed?) density))
	    transitions (apply hash-map (interleave (for [_ (range num-nodes)] (keyword (gensym)))
						    (repeat #{})))]
       (if (zero? connections)
	 (graph (keys transitions)
		transitions
		(fn [selection-function input] (selection-function transitions))
		keys
		nil
		(fn [loc] (zero? (count (transitions loc))))
		identity)
	 (let [[from to] (choose-random-unconnected-nodes transitions directed?)]
	   (if (or directed? (= from to))
	     (recur (dec connections)
		    (assoc transitions from (conj (transitions from) to)))
	     (recur (dec (dec connections))
		    (-> (assoc transitions from (conj (transitions from) to))
			((eval (fn [tmap] (assoc tmap to (conj (tmap to) from)))))))
	     )))))
  ([num-nodes density] (generate-random-graph num-nodes density false)))


(graph-utils/generate-random-graph 6 0.25 false)

(comment
  
(def undirected-graph (generate-random-graph 10 0.5))
(def directed-graph (generate-random-graph 10 0.5 true))
;; get back the transition map:
;;(((meta undirected-graph) :graph/transition) nil (fn [a b] b))
;;(((meta directed-graph) :graph/transition) nil (fn [a b] b))

(def
 ^{:doc "11*00*"}
 test-regexp
 (graph-utils/graph
  #{"start" "1" "1+" "1+0" "1+0+" "dead"}
  {"start" {"1" "1"}
   "1" {"1" "1+" "0" "1+0"}
   "1+" {"1" "1+" "0" "1+0"}
   "1+0" {"0" "1+0+"}
   "1+0+" {"0" "1+0+"}
   "dead" {}}
  (fn [loc] (fn [input] (((:neighbors (meta loc)) (node loc)) input "dead")))
  (fn [_] "start")
  nil
  (fn [loc] (or (= (node loc) "dead")
		(= (node loc) :reject)))
  (fn [g] (if (= (node g) "1+0+") :accept :reject))))
)